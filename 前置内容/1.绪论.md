## 绪论

### 数据是什么？
数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被计算机程序识别处理的
符号和集合。数据是计算机程序加工的原料

数据元素、数据项

数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，一个数据元素可由若干数据项组成

数据项是构成数据元素不可分割的最小单位

##### 数据元素 -- 描述一个个体

什么是数据对象？

一个数据元素是我们描述的一个个体，数据项就是组成这个数据元素的所有信息

一个数据对象就包含多条数据元素

所谓的数据对象就是具有相同性质的数据元素的集合，是一个数据的子集

##### 数据结构
就是指相互之间存在一种或者多种特定关系的数据元素的集合。

数据结构更强调的是数据元素互相之间的关系，而数据对象更加强调每一个i而数据结构个体里边的这些性质要相同



----

### 数据结构的三要素：

 - 逻辑结构
		 - 集合结构
		 - 线性结构   1:1
		 - 树形结构   1:n
		 - 图状结构   n:n

 - 物理结构 存储结构

 - 数据的运算

#### 逻辑结构

###### 集合
各个元素同属于一个集合，别无其他的关系，与数学里集合的概念是一样的

###### 线性结构
数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继；

即数据其实是会按照顺序排序，就跟排队一样

###### 树形结构
数据元素之间是一对多的关系

就是数据结构李的树

Linux的文件系统等

###### 网状结构  也叫图状结构
数据元素多对多的关系

比如好友列表关系  城市交通分布图 

#### 数据的运算
针对某种逻辑结构，结合实际需求，定义基本运算

增删改查

结合逻辑结构、实际需求来定义基本运算

#### 存储结构
如何用计算机表示数据元素的逻辑关系

顺序存储：将所有数据按照顺序排列存储，根据先后顺序表示数据的排列，相邻元素必须相邻

链式存储：逻辑上相邻的元素可以不相邻，通过元素存储地址的指针来表示元素之间的逻辑关系

索引存储：在存储元素信息的同事，还建立附加的索引表。索引表中每项成为索引项，索引项的格式一般是 关键字:地址

散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为哈希存储 ** 这个比较重要  要理解hash

1. 若采用顺序存储  则各个数据元素在物理上必须是连续的，若采用非顺序存储，则哥哥元素在物理上可以是分散的

2. 数据的存储结构会影响存储空间分配的方便程度

3. 数据的存储结构会影响对数据运算的速度

运算的定义是针对逻辑结构的，指出运算的功能

运算的实现是针对存储结构的，指出运算的具体操作和步骤

### 数据类型、抽象数据类型
数据类型是一个支的集合和定义在此几何上的一组操作的总称

1. 原子类型。其值不可再分的数据类型
	bool类型  int类型

2. 结构类型 其值可以再分解为若干成分的数据类型


抽象数据类型 ADT abstract data type 是抽象数据组织及之相关的操作


### 算法的基本概念
程序 = 数据结构＋算法

数据结构：如何用数据正确地描述现实世界的问题并存入计算机

算法：如何高效的处理这些数据，以解决实际问题。算法 Algorithm 是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作

##### 算法应该具有的特性

1. 有穷性 一个算法必须总在执行有穷步骤后结束，并且每一步都可以在有穷时间内完成 (算法是有穷的，程序是无穷的)
2. 确定性 算法中的每条指令必须有确切的含义，对于相同的输入只能得到相同的输出
3. 可行性 算法中描述的操作都可以通过已实现的基本运算执行有限次来实现
4. 输入 一个算法有零个或者多个输入，这些输入取自于某个特定的对象集合
5. 输出 一个算法有一个或者多个输出，这些输出是与输入有着某种特定关系的量

##### 评判好算法的特性
1. 正确性  算法要能够正确的解决求解问题
2. 可读性  算法应具有良好的可读性，以帮助人们理解
3. 健壮性  输入非法数据时要适当的对错误数据作出反应或者进行处理，不会莫名其妙的产出结果
4. 高效率与低存储量  花费较少的时间和空间 -- 时间复杂度和空间复杂度

### 算法的效率度量
##### 算法的空间复杂度
--> ../code/Complexity_measurement/space_complexity.c

##### 算法的时间复杂度
事前估计算法时间开销 T(n) 与问题规模 n 之间的关系
--> ../code/Complexity_measurement/time_complexity.c

##### 复杂度分析
主定理公式: T(n) = aT(n/b) + f(n)

a >= 1; b > 1;是给定的函数，这种形式的递归式很常见，刻画了一个分治算法，生成a个子问题，每个子问题是原来的1/b，分解和合并步骤共消耗f(n)

主方法是计算时间复杂度的时候用的

1. 若对于某常数t>0, 有 f(n) = O(n^(log.b(a)-t)) 则 T(n) = O(n^log.b(a))
2. 若f(n) = Θ(n^log.b(a)), 则有 T(n) = Θ(n^(log.b(a))*lg(n))
3. 若对某常数 t>0,有f(n) = Ω(n^(log.b(a)+t)),且对于常数c<1与所有足够大的n，都有a*f(n/b) <= cf(n),则T(n) = Θ(f(n))

举例
1. T(n) = 4T(n/2) + O(nlogn)
2. T(n) = 4T(n/2) + O(n^2)
3. T(n) = 3T(n/3) + O(n^2)
4. T(n) = T(n/2) + O(log^2(n))

对于第一题：f(n) = O(n^(log.2(4)-1)) 所以取大的=> O(n^2)   所以这里的时间复杂度为 O(n^2)

第二题 f(n) = O(n^(log.2(4))) ==> 时间复杂度为 O(n^2*lg(n))

第三题 f(n) 大，取 O(n^2)

第四题 O(lg(n))

```cpp
void func(int n) {
	if (n > 1) {
		func(n/2);
		cout << "test" << endl;
		func(n/2);
	}
}
```
上题，无法直接判断时间复杂度，我们可以用主定理公式

T(n) = 2T(n/2) + O(1)

T(n) = O(n)

```cpp
void func(int n) {
	if (n > 1) {
		func(n/2);
		for(int i = 0; i<n; i++) cout<< "1" << endl;
		func(n/2);
	}
}
```
T(n) = 2T(n/2) + O(n)

T(n) = O(n*lgn)

```cpp
using namespace std;
int binary_search(vector<int> a, int t) { // 二分查找  只有有序数组能用二分查找
    int l = 0, r = a.size()-1;
    while (l <= r) {
        int m = (l+r)/2;
        if (a[m] == t) return m;
        else if (a[m]<t) l = m + 1;
        else r = m - 1;
    }
}
```
T(n) = T(n/2) + O(1)  -->  O(lgn)